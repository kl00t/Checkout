The approach I made for this exercise was to use the TDD approach using a cycle of Red-Green-Refactor. I firstly wrote my unit test scenario and developed code based upon the criteria that I am testing, in this case the result of GetTotalPrice.

Obviously, the first step I took was to create a class library containing a Checkout class and a Checkout.Tests project. I took the opportunity to add the NUnit test package as I am familiar with this Nuget package. I create the interface as described in the instructions and chose to implement this in my checkout class.

The first test created was to ensure that no scanned items returns zero price. This was the most basic test initially. Using a strategy of pure TDD I chose to hardcode the result to get the test to pass and then write a further test with the intention of refactoring this at a later date as my test scenarions grow.

The next test was added and I began to notice duplicate code in my test class which I then began to refactor to avoid duplication. The next test was created and the existing code was refactored. I continued this process adding tests, adding code and refactoring until my test scenarios grew. I decided at this point it would be a good idea to use mocking using Moq nuget package to establish a set of test data reflecting the examples. I then introduced the repository pattern to separate out the code, as in a real world scenario we would be getting this data from a service or database. This meant there was a slight overhead as I needed to ensure that this would not break existing tests. I began to unit test the repository. I also introduced dependencny injection to handle the mock test scenarions.

I added a custom exception in order to handle any errors returning from the repository if the product could not be find. At this point I began to consider the real world scenario of a checkout and introduced the concept of a Basket which could be filled when items were scanned at the checkout. The basket total would then be calculated along with the discounts. The Special Offer property was applied to the Product class as the assumption was that the special offer applied to the product itself. I added an IsAvailabel property to turn on/off the special offer for the product as well as Quantity and Discount properties. The Quantity is used to set the amount of items needed for the discount to apply. The Discount property is added to the total discounts.

Finally, I added a SubTotal and TotalDiscounts properties to separate the values as well as a GetTotalDiscounts() method that showed the amount of discounts applied to the items in total. The code was refactored to move the CalculatePrice() method to a private method. This would be called when GetTotalPrice() method is called and all the product prices can be recalculated. I also added a resource file to hold custom variable string messages.

The CancelScan() was added because in a real world scenario mistakes can be made and scanned items would needed to be taken off the checkout line. This was handled very easily becauase I used the TDD approach and I was able to write some simple tests to allow this to be tested and developed.

A final refactoring was done to remove obsolete or unused code and also to apply Microsoft code analysis recommendations. My code is fully documented with XML comments which can be used to export to an external file for help documentation.